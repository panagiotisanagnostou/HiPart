# Copyright (c) 2022 Panagiotis Anagnostou

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
"""
Implementation module for the static visualization of the algorithms implemented
in the HiPart package.

"""

import HiPart.__utility_functions as util
import math
import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt

from scipy.cluster.hierarchy import dendrogram
from HiPart.clustering import BisectingKmeans
from HiPart.clustering import DePDDP
from HiPart.clustering import IPDDP
from HiPart.clustering import KMPDDP
from HiPart.clustering import PDDP


def split_visualization(hipart_object, color_map="tab20"):
    """
    Create the visualization of each of the splits generated by one of the
    divisive hierarchical clustering algorithms, members of HiPart package.
    For each split, we visualize the data on the first two principal
    components, while the color of each sample is chosen depending on the
    cluster it belongs to. The colors throughout the separate split represent
    the same cluster each time.

    Depending on the input object, the visualization is enriched with
    additional information related to the algorithm that created it. For the:

    1. DePDDP object, the visualization adds a marginal plot on the X-axis that
    represents the density of the data as extracted from the kernel density
    estimation for the first principal component. That is the information the
    dePDDP algorithm utilizes to split each cluster.

    2. KMPDDP object, the visualization adds a marginal plot on the X-axis
    that represents the data as they are projected on the first principal
    component, with the addition of the centers the k-Means finds within its
    execution on each split. That is the information the kM_PDDP algorithm
    utilizes to split each cluster.

    3. iPDDP along with PDDP objects, the visualization adds a marginal plot on
    the X-axis that represents the data as they are projected on the first
    principal component. That is the information the iPDDP algorithm utilizes
    to split each cluster.

    4. BisectingKmeans object does not include additional information in the
    visualization. That is because of the nature of the algorithm it
    implements.

    Finally, for all the objects the visualization adds the selected split
    point for each split by each algorithm. This way one can validate the
    execution and the results of each algorithm. Moreover, examining this
    visualization can help the parametrization of the algorithms.

    Parameters
    ----------
    hipart_object : dePDDP or iPDDP or kM_PDDP or PDDP or BisectingKmeans
        The object member of HiPart package that we want to manipulate on the
        premiss of this function.
    color_map : string
        The name of the matplotlib color map to be used for the data
        visualization.

    Raises
    ------
    TypeError
        If the hipart_object is not a member of the HiPart package raise an
        error for the possibility of unexpected errors that will be raised
        if the elements of the object are not correctly structured.
    ValueError
        If the "visualization_utility" attribute of the imported object is
        False, this causes some needed for this visualization data not
        to be created.

    Returns
    -------
    plt : pyplot (module)
        The created visualization by this function.

    """

    # Check data compatibility with the function
    if isinstance(hipart_object, DePDDP):
        if not hipart_object.visualization_utility:
            raise ValueError(
                """The visualization of the data cannot be archived because the
                visualization_utility is False."""
            )
        with_hist = True
        with_marginal_scatter = False
        grid_size = 4
    elif (
        isinstance(hipart_object, IPDDP)
        or isinstance(hipart_object, KMPDDP)
        or isinstance(hipart_object, PDDP)
    ):
        if not hipart_object.visualization_utility:
            raise ValueError(
                """The visualization of the data cannot be archived because the
                visualization_utility is False."""
            )
        with_hist = False
        with_marginal_scatter = True
        grid_size = 4
    elif isinstance(hipart_object, BisectingKmeans):
        with_hist = False
        with_marginal_scatter = False
        grid_size = 2
    else:
        raise TypeError("can only process objects of the 'HiPart' package.")

    # prepare the necessary data for this visualization
    dictionary_of_nodes, internal_nodes, _, sample_color = util.visualization_preparation(
        hipart_object, color_map
    )
    number_of_splits = len(internal_nodes)

    # Ensure that the root node will be always an internal node while is the
    # only node in the tree
    if number_of_splits == 0:
        internal_nodes = [0]

    # select the number of plot sub-figures
    row_plots = 3 if math.ceil(number_of_splits) > 4 else 2

    # set figure size
    fig = plt.figure(
        figsize=(4 * row_plots, 3.5 * math.ceil(number_of_splits / row_plots)),
    )

    # create grid for sub-figures
    gs = gridspec.GridSpec(
        math.ceil(number_of_splits / row_plots) * grid_size,
        row_plots * grid_size,
        fig,
    )

    hists = []
    hist_indicator = 0

    for i in range(number_of_splits):
        # Extract the subplot position
        row_from, row_to, col_from, col_to = util.grid_position(
            current=i,
            rows=row_plots,
            splits=number_of_splits,
            with_marginal=(with_hist or with_marginal_scatter),
        )

        # get the color of the sample that belong to the i internal node
        pr_col = sample_color[
            hipart_object.tree.get_node(internal_nodes[i]).data["indices"]
        ]

        # differentiate the visualizations which need explanatory margin plot
        # from simple visualizations
        if with_hist:
            principal_projections = dictionary_of_nodes[
                internal_nodes[i]
            ].data["projection"]
            splitPoint = dictionary_of_nodes[
                internal_nodes[i]
            ].data["splitpoint"]

            scatter = plt.subplot(gs[row_from + 1: row_to, col_from:col_to])
            if i == 0:
                total_elements = hipart_object.tree.get_node(
                    internal_nodes[i]
                ).data["indices"].shape[0]

            hist = plt.subplot(
                gs[row_from: row_to - 3,  col_from:col_to],
                sharex=scatter,
            )
            hists.append(hist)

            util.make_scatter_n_hist(
                scatter=scatter,
                hist=hist,
                PP=principal_projections,
                splitPoint=splitPoint,
                bandwidth_scale=hipart_object.bandwidth_scale,
                pr_col=pr_col,
                scaler=total_elements,
            )
            current_ylim = hist.get_ylim()
            hist.set_ylim(hists[hist_indicator].get_ylim())

            if hists[hist_indicator].get_ylim()[1] < current_ylim[1]:
                hist_indicator = i
                for j in hists:
                    j.set_ylim(current_ylim)

            hist.title.set_text(
                "Original data with 1st split"
            ) if i == 0 else hist.title.set_text("Split no. " + str(i + 1))

        elif with_marginal_scatter:
            principal_projections = dictionary_of_nodes[
                internal_nodes[i]
            ].data["projection"]
            splitPoint = dictionary_of_nodes[
                internal_nodes[i]
            ].data["splitpoint"]

            scatter = plt.subplot(gs[row_from + 1: row_to, col_from:col_to])
            marginal_scatter = plt.subplot(
                gs[row_from: row_to - 3, col_from:col_to], sharex=scatter
            )
            centers = dictionary_of_nodes[
                internal_nodes[i]
            ].data["centers"] if isinstance(hipart_object, KMPDDP) else None
            util.make_scatter_n_marginal_scatter(
                scatter=scatter,
                marginal_scatter=marginal_scatter,
                PP=principal_projections,
                splitPoint=splitPoint,
                pr_col=pr_col,
                centers=centers,
            )

            marginal_scatter.title.set_text(
                "Original data with 1st split"
            ) if i == 0 else marginal_scatter.title.set_text(
                "Split no. "
                + str(i + 1)
            )

        else:
            # Bisecting k-Means doesn't execute PCA, so we execute it here for
            # the visualization
            if isinstance(hipart_object, BisectingKmeans):
                principal_projections = util.execute_decomposition_method(
                    data_matrix=hipart_object.X[
                        dictionary_of_nodes[internal_nodes[i]].data["indices"]
                    ],
                    decomposition_method="pca",
                    two_dimentions=True,
                    decomposition_args={},
                )
                show_split = False
                splitPoint = None
            else:
                principal_projections = dictionary_of_nodes[
                    internal_nodes[i]
                ].data["projection"]
                show_split = True
                splitPoint = dictionary_of_nodes[
                    internal_nodes[i]
                ].data["splitpoint"]

            # create each individual visualization
            ax = plt.subplot(gs[row_from:row_to, col_from:col_to])
            ax = util.make_simple_scatter(
                sp=ax,
                splitPoint=splitPoint,
                PP=principal_projections,
                pr_col=pr_col,
                show_split=show_split,
            )

            # title the subplot
            ax.title.set_text(
                "Original data with 1st split"
            ) if i == 0 else ax.title.set_text("Split no. " + str(i + 1))

    plt.subplots_adjust(wspace=0.2, hspace=0.6)
    return plt


def dendrogram_visualization(hipart_object, **dendrogram_parameters):
    """
    Create a dendrogram visualization of the divisive clustering based on the
    HiPart`s algorithm execution. The characteristic of this dendrogram is that
    the distance of the clusters is not the one depicted on the graph, but it
    represents the distance of each node from the base of the tree, also known
    as leaves.

    Parameters
    ----------
    hipart_object : dePDDP or iPDDP or kM_PDDP or PDDP or BisectingKmeans
        The object member of the HiPart package that we want to manipulate on
        the premiss of this function.
    **dendrogram_parameters : dict
        All the parameters the scipy.cluster.hierarchy.dendrogram function can
        take except the color_threshold parameter. Except for the
        "color_threshold" parameter. This parameter takes a default threshold
        because, in the linkage, we do not calculate the actual distance of the
        found clusters but only their hierarchy.

    Raises
    ------
    TypeError
        If the hipart_object is not a member of the HiPart package, the
        function raises a "TypeError" error. The error is raised for the
        possibility of unexpected faults if the elements of the hipart_object
        are not correctly structured.

    Returns
    -------
    dn : dict
        A dictionary of data structures created to render the dendrogram.

    """

    if not (
        isinstance(hipart_object, DePDDP)
        or isinstance(hipart_object, IPDDP)
        or isinstance(hipart_object, KMPDDP)
        or isinstance(hipart_object, PDDP)
        or isinstance(hipart_object, BisectingKmeans)
    ):
        raise TypeError("can only process objects of the 'HiPart' package.")

    Z = util.create_linkage(hipart_object.tree)
    dn = dendrogram(Z, color_threshold=0.3, **dendrogram_parameters)

    return dn


def linkage(hipart_object):
    """
    Create the linkage of the data based on the divisive hierarchical
    clustering for the members of the HiParts package. The linkage's
    characteristic is that the cluster distance on the third column of the
    linkage is not the distance of the clusters with each other, but it
    represents the distance of each node from the base of the tree, also
    known as leaves.

    Parameters
    ----------
    hipart_object : dePDDP or iPDDP or kM_PDDP or PDDP or BisectingKmeans
        The object member of HiPart package that we want to manipulate on the
        premiss of this function.

    Returns
    -------
    Z : numpy.ndarray
        The divisive clustering encoded as a linkage matrix.

    """

    if not (
        isinstance(hipart_object, DePDDP)
        or isinstance(hipart_object, IPDDP)
        or isinstance(hipart_object, KMPDDP)
        or isinstance(hipart_object, PDDP)
        or isinstance(hipart_object, BisectingKmeans)
    ):
        raise TypeError("can only process objects of the 'HiPart' package.")

    return util.create_linkage(hipart_object.tree)
